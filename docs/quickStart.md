# Semantic Engine QuickStart Guide

This guide will get a user up and running quickly with the Semantic Engine. It should not be considered complete documentation. The Semantic Engine requires an application ontology and a Graph Specification (restriction on the ontology) to be provided. This guide will not cover building an application ontology or Graph Specification (GS), but will use the publically available [TURBO ontology](https://raw.githubusercontent.com/PennTURBO/turbo-ontology/master/ontologies/turbo_merged.owl) and [turbo_valid_graph_specification](https://github.com/PennTURBO/semantic-engine/blob/master/drivetrain/config/graph_specifications/turbo_valid_graph_specification.gs).

**First**, follow the installation instructions on the README. Once you have created `turbo_properties.properties` from the template, open it in a text editor. You should see something like this at the top of the file:

```
productionServiceURL = http://your_prd_db:7200/
productionUsername = your_username
productionPassword = your_password
productionRepository = your_prd_repo

testingServiceURL = http://your_dev_db:7200/
testingUsername = your_username
testingPassword = your_password
testingRepository = your_testing_repo

modelServiceURL = http://your_db:7200/
modelUsername = your_username
modelPassword = your_password
modelRepository = your_model_repo
```
You will need to create three repositories in an RDF4J-compliant triplestore (or two, if you want the production and testing repositories to be the same, but that is not recommended). We recommend using a setting with no reasoning/inference for all three repositories. Using a reasoning-enabled repository may cause the tests to fail or other unexpected results. If necessary, reasoning can be applied at the end of an instantiation by setting `reinferRepo` to `true` in the properties file. Once you've created these repositories, fill in the URLs, usernames, passwords, and repository names in the section of the properties file shown above. They can be on the same or on different database servers. Below is a description of what the repositories will be used for:

*Production Repository*: Stores the output of a Semantic Engine instantiation. Concise RDF data that is input to the Semantic Engine processes should be loaded here before running the Semantic Engine.

*Testing Repsository*: Stores temporary data related to integration and functional tests that are part of the ScalaTest suite of tests, as well as the Snapshot tests that test individual updates within specific Transformation Instruction Sets (TIS) and can be generated by a user. Data intended to persist should not be stored here.

*Model Repository*: Stores the TIS and GS that is being used for an actively running Semantic Engine instantiation or test, as well as the Semantic Engine Language ontology, which specifies the allowed terms within the TIS and GS. This data will be copied automatically from the file sources by the Semantic Engine. The user should never have to delete, modify, or add data manually to this repository.

**Second**, find the setting in the properties file with key `instructionSetFile`. Replace the placeholder value with `quickStart.tis`. Then, create a blank file with that name in the directory `drivetrain/config/transformation_instruction_sets`. You'll want to add some namespace prefixes to make things easier, so open `drivetrain/config/prefixes.txt` and add the following prefixes to the bottom of the list of already known prefixes:

```
PREFIX semanticEngine: <https://github.com/PennTURBO/Drivetrain/>
PREFIX inputSchema: <http://SemanticEngineQuickStart.edu/RdfSchema/>
```

The `semanticEngine` prefix will used to reference terms specific to the Semantic Engine Language, as defined in the [Semantic Engine Language Ontology](https://github.com/PennTURBO/semantic-engine/blob/master/drivetrain/ontologies/acornOntology.ttl). The `inputSchema` prefix will be used to refer to the schema of the incoming concise RDF data.

**Third**, add the following triples representing a concise RDF dataset with patient identifiers to your *Production Repository*, in named graph `https://github.com/PennTURBO/Drivetrain/inputTriples`. These triples will be the input to the Update Specification that we will create in the TIS.

```
inputSchema:homoSapiens_1 rdf:type inputSchema:homoSapiens .
inputSchema:homoSapiens_1 inputSchema:identifier 1 .

inputSchema:homoSapiens_2 rdf:type inputSchema:homoSapiens .
inputSchema:homoSapiens_2 inputSchema:identifier 2 .

inputSchema:homoSapiens_3 rdf:type inputSchema:homoSapiens .
inputSchema:homoSapiens_3 inputSchema:identifier 3 .
```

One way to accomplish this would be to launch the following SPARQL query against the database's web interface:
```
prefix inputSchema: <http://databaseA.org/RdfSchema/> 
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
insert data
{
    graph <https://github.com/PennTURBO/Drivetrain/inputTriples>
    {
        inputSchema:homoSapiens_1 rdf:type inputSchema:homoSapiens .
        inputSchema:homoSapiens_1 inputSchema:identifier 1 .

        inputSchema:homoSapiens_2 rdf:type inputSchema:homoSapiens .
        inputSchema:homoSapiens_2 inputSchema:identifier 2 .

        inputSchema:homoSapiens_3 rdf:type inputSchema:homoSapiens .
        inputSchema:homoSapiens_3 inputSchema:identifier 3 .
    }
}
```

**Fourth**, model the schema used to represent the concise RDF data by building Connection Recipes in the TIS. The following Connection Recipes should be added to `quickStart.tis` below the prefix declarations:
```
semanticEngine:personToIdentifier a semanticEngine:InstanceToLiteralRecipe ;
  semanticEngine:subject inputSchema:homoSapiens ;
  semanticEngine:predicate inputSchema:identifier ;
  semanticEngine:object semanticEngine:person_cridsym_LiteralValue ;
  semanticEngine:cardinality semanticEngine:1-1 ;
.
semanticEngine:person_cridsym_LiteralValue
  a semanticEngine:StringLiteralResourceList ;
.
semanticEngine:shortcutHomoSapiensToExpandedHomoSapiens a semanticEngine:InstanceToInstanceRecipe ;
  semanticEngine:subject inputSchema:homoSapiens ;
  semanticEngine:predicate turbo:TURBO_0010113 ;
  semanticEngine:object obo:NCBITaxon_9606 ;
  semanticEngine:cardinality semanticEngine:1-1 ;
.
inputSchema:homoSapiens 
    a owl:Class 
.
```
Try to look at the Connection Recipe above and the schema of the concise RDF triples and understand how one models the other. The Connection Recipe `personToIdentifier` models a triple pattern with a subject that is an instance of class `inputSchema:homoSapiens`, a predicate of `inputSchema:identifier`, and a literal value as the object. We assert that `inputSchema:homoSapiens` is a class. We further specify that the literal value, represented by an instance of class `drivetrain:StringLiteralResourceList`, should be of type string. Currently type enforcement of literal values in an incoming data source does not exist in the Semantic Engine, but it should be added without too much difficulty.

The `drivetrain:cardinality` setting indicates that for each instance of an `inputSchema:homoSapiens`, there should only be one associated literal value that is the `inputSchema:identifier`. In an alternative world where we should expect multiple identifiers per person, the setting `drivetrain:1-many` could be used instead of `drivetrain:1-1`.

Note that although there are 3 triples in the input dataset that conform to the pattern specified (with subjects `inputSchema:homoSapiens_1`, `inputSchema:homoSapiens_2`, and `inputSchema:homoSapiens_3`), this makes no difference to the TIS. The Connection Recipe specifies the existence of a pattern, and all occurrences of that pattern will be processed.

The instance `drivetrain:person_cridsym_LiteralValue` is already declared as an instance of the generic type `drivetrain:LiteralResourceList` in the GS file that we will use. We have adopted the convention that literal values that will be represented in the RDF output should be declared in the GS. If the datatype of that literal is unambigous, then it can be declared in the GS with a specific datatype, but if the datatype varies based on the incoming data source, it should be declared generically in the GS and more specifically in the TIS, as we have done here.

**Fifth**, create an Update Specification (TURBO ontology term `turbo:TURBO_0010354`) that references the Connection Recipe we have just created as an input, and additional Connection Recipes in the GS to build the output graph pattern based on the input. Add the following Update Specification to the TIS file:
```
semanticEngine:expandPatientIdentifiers a turbo:TURBO_0010354 ;
  semanticEngine:inputNamedGraph semanticEngine:inputTriples ;
  semanticEngine:outputNamedGraph semanticEngine:expandedTriples ;
  semanticEngine:hasRequiredInput semanticEngine:personToIdentifier ;
  semanticEngine:hasRequiredInput semanticEngine:shortcutHomoSapiensToExpandedHomoSapiens ;
  semanticEngine:hasOutput semanticEngine:symbolPartOfCrid ;
  semanticEngine:hasOutput semanticEngine:symbolHasRepresentation ;
  semanticEngine:hasOutput semanticEngine:drivetrain:CridDenotesPatient ;
.
```
Each object of a triple with predicate `semanticEngine:hasOutput` represents a Connection Recipe already defined in the GS. Our Update Specification creates a partial representation of the full semantic model, including only fields relevant to the schema of our incoming data.

**Finally**, from the `drivetrain/` directory, start the SBT console and run the Semantic Engine with the command `run https://github.com/PennTURBO/Drivetrain/expandPatientIdentifiers`. Once the instantiation finishes, check your production repository to see the expanded data in the graph `https://github.com/PennTURBO/Drivetrain/expandedTriples`. The original concise RDF data should be preserved as well.
